# -*- coding: utf-8 -*-
"""count.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B4ECsN0KuZMfpD4_ztG9OPZhWo7bmpm7
"""

from random import seed
from random import randint
from random import choice
import math
import numpy as np
import hashlib
import time

import Key_Generation as keygen


def prime_check(x):
  checker = True
  for i in range (2,x):
    if (x%i == 0):
      checker = False
      break
  return checker

def generate(sk):
  # sequences = [16,32,64]
  # n = choice(sequences)
  # # print(n) 


  # prime_range = 1000
  # prime_num = [0 for i in range (prime_range)]
  # for i in range (prime_range):
  #   prime_num[i]=2*n+i+1

  # idx = 0
  # p = prime_num[idx]
  # check = False
  # while (check == False or idx ==9999):
  #   prime = prime_check(p)
  #   if (prime == False):
  #     idx = idx+1
  #     # print(idx)
  #     p = prime_num[idx]
  #   else:
  #     if (p%(2*n) == 1):
  #       check = True
  #     else:
  #       idx = idx+1
  #       # print(idx)
  #       p = prime_num[idx]
  # print("P = ",p)

  # main_koef = (p - 1)/2

  # s_one = [0 for i in range (n)]
  # s_two = [0 for i in range (n)]

  # s_koef = [-1,0,1]

  # for i in range (n):
  #   koef = choice(s_koef)
  #   s_one[i] = koef
  # s_one = np.poly1d(s_one)

  # for i in range (n):
  #   koef = choice(s_koef)
  #   s_two[i] = koef
  # s_two = np.poly1d(s_two)
  # print("KOEF",len(s_two.coeffs))

  # a = [0 for i in range (n)]

  # a_koef = [i for i in range (math.floor(main_koef))]
  # negative = [-1,1]

  # for i in range (n):
  #   koef = choice(a_koef)
  #   koef = koef * choice(negative)
  #   a[i] = koef
  # a = np.poly1d(a)

  # t = (a*s_one) + s_two

  n = len(sk[0].coeffs)
  k = randint(2,math.floor(math.sqrt(n)-1))

  return n,k

def step1(n,k):

  
  y_one = [0 for i in range (n)]
  y_two = [0 for i in range (n)]
  y_koef = [0 for i in range (k)]
  
  for i in range(k):
      y_koef[i] = i
      
  # print("y_koef =", y_koef)
  negative = [-1,1]

  for i in range (n):
    koef = choice(y_koef)
    koef = koef * choice(negative)
    y_one[i] = koef
  y1 = np.poly1d(y_one)

  for i in range (n):
    koef = choice(y_koef)
    koef = koef * choice(negative)
    y_two[i] = koef
  y2 = np.poly1d(y_two)

  # print("")
  # print("y1= ",y1)
  # print("")
  # print("y2= ",y2)
  # print("")
  return y1,y2

def step2(a,y_one,y_two,m):
  temp = (a*y_one) + y_two

  temp = temp.coeffs
  # print("a*y1+y2 = ",temp)
  concat = str(temp[0])
  for i in range(1,len(temp)):
    concat = concat + str(temp[i])
  concat = concat + m
#   print(concat)

  sha1 = hashlib.sha1(concat.encode('utf-8'))
  sha1 = sha1.hexdigest()
#   print(sha1)

  
  n = int(sha1, 16) 
  bStr = ''
  while n > 0:
      bStr = str(n % 2) + bStr
      n = n >> 1    
  res = bStr

  # print(res)
  # print(len(res))

  return res

def hashing(input):
  split = [char for char in input]
#   print("Split ==", split)
  # ADD 0 if binary length not 160
  if len(split)<160 :
    for i in range (160 - len(split)):
      split.insert(0,'0')
  # print("LENGTH BEFORE : ",len(split))

  # change type to int
  for i in range (len(split)):
    split[i] = int(split[i])

  # convert 160 to 512
  new = []
  for i in range (len(split)):

    if i % 5 == 0:
      dec = split[i+1]*8 + split[i+2]*4 + split[i+3]*2 + split[i+4]*1
      for  j in range (16):
        if j == dec:
          if dec == 0:
            new.append(-1)
          else:
            new.append(1)
        else:
          new.append(0)

  return new

def step3 (s_one,s_two,y_one,y_two,c):
  c= np.poly1d(c)
  z_one = s_one * c + y_one
  z_two = s_two * c + y_two

  z_one = z_one.coeffs
  z_two = z_two.coeffs

  return z_one,z_two

def z_checker (z_one,z_two,k):
  # print("len z: ",len(z_one) )
  num1 = 0
  for i in range (len(z_one)-1):
    if (z_one[i] >= k-32):
      num1 = num1 + 1
  num2 = 0
  for i in range (len(z_two)-1):
    if (z_two[i] >= k-32):
      num1 = num1 + 1
  
  if (num1 == len(z_one)) and (num2 == len(z_two)):
    check = True


  check = True
  return check

def Signing(m,a,sk,k):
  n = len(sk[0].coeffs)

  s_one= sk[0]
  s_two= sk[1]

  check = False
  while (check != True):
    ystart = time.time()
    y_one, y_two= step1(n,k)
    ystop = time.time()
    # print("step 1 done")
    binstart = time.time()
    bin = step2(a,y_one,y_two,m)
    binstop = time.time()
    # print("step 2 done")
    hasstart = time.time()
    c_hash = hashing(bin)
    hashstop = time.time()
    # print("step hash done")
    zstart = time.time()
    z_one,z_two = step3 (s_one,s_two,y_one,y_two,c_hash)
    zstop = time.time()
    # print("step 3 done")
    checkstart = time.time()
    check = z_checker(z_one,z_two,k)
    checkstop = time.time()
    print("y: ", ystop - ystart)
    print("bin: ", binstop - binstart)
    print("hash: ", hashstop - hasstart)
    print("z: ", zstop - zstart)
    print("check: ", checkstop - checkstart)
    check = True

  z1 = to_string(z_one)  
  z2 = to_string(z_two) 
  c =  to_string(c_hash)  
  # for i in range(len(z_one)-1):
  #   z1 = z1+ str(z_one[i])
  #   z2 = z2+ str(z_two[i])

  # for i in range(len(c_hash)-1):
  #   c = c+ str(c_hash[i])
  signature = [z1, z2, c]
  return signature


def to_string(arr):
  text = ""
  for i in range(len(arr)):
    text = text + str(arr[i])
  return text

def to_array(text):
  arr = [char for char in text]
  res = []
  # print(len(arr))
  # print(len(res))
  count_negative=0
  negative= []
  for i in range (len(arr)):
    if (arr[i]=='-'):
      negative.append(i)
  # print(negative)

  for i in range (len(arr)):
    if (arr[i] != '-'):
      res.append(int(arr[i]))
  # print(res)
  # print("lenres ", len(res))
  for i in range (len(negative)):
    res[negative[i]-count_negative] = res[negative[i]-count_negative] * -1
    count_negative = count_negative+1

  return res


def verifying (msg,signature,pk,k):
  a = pk[0]
  t=pk[1]
  # print("this is m: ",msg[0]['email'])

  m = msg[0]['email']+msg[0]['parking_space']+str(msg[0]['time'])+str(msg[0]['payment'])+str(msg[0]['payment_status'])+str(msg[0]['parking_status'])

  z1_arr = to_array(signature[0])
  z2_arr = to_array(signature[1])
  c = to_array(signature[2])

  z_one = np.poly1d(z1_arr)
  z_two = np.poly1d(z2_arr)
  

  a = np.poly1d(a)
  t = np.poly1d(t)
  c_poly = np.poly1d(c)

  temp = a*z_one + z_two - t*c_poly
  print ("")
  temp = temp.coeffs
  print ("a*z1 + z2 - t*c = ",temp)
  concat = str(temp[0])

  for i in range(1,len(temp)):
    concat = concat + str(temp[i])
  concat = concat + m
  # print(concat)

  sha1 = hashlib.sha1(concat.encode('utf-8'))
  sha1 = sha1.hexdigest()
  # print(sha1)

  
  n = int(sha1, 16) 
  bStr = ''
  while n > 0:
      bStr = str(n % 2) + bStr
      n = n >> 1    
  res = bStr

  hash = hashing(res)

#   print("INI CEK HASH ===",hash)
#   print("INI CEK C ===",c)

  checker = z_checker(z_one,z_two,k)

  Status = False
  if (hash == c and checker == True):
    print("Acc")
    Status = True

  return Status


kg = keygen.key_Generator()
m = "test"
sk,pk,k,a = kg.generate()
Signing(m,a,sk,k)

# m = '1'
# n,s_one,s_two,a,t,k = generate()
# print("n = ",n)
# print("k = ",k)
# print("s1 = ")
# print(s_one)
# print()
# print()
# print("s2 = ",s_two)
# print()
# print()
# print("a = ",a)
# print()
# print()
# print("t = ",t)
# print()
# print()
# signature = Signing(n,m,a,s_one,s_two,k)
# print (signature)
# print(" - ")
# status = verifying(m,signature,a,t,k)
# print(status)



# new = hash(input)
# counter = 0
# # print(new)
# for i in range (len(new)):
#   # print(new[i])
#   if new[i] == 1 or new[i] == -1:
#     counter = counter +1
# # print(new)
# print("LENGTH AFTER: ",len(new))
# print("ONES: ", counter)